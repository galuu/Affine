%% This template can be used to write a paper for
%% Computer Physics Communications using LaTeX.
%% For authors who want to write a computer program description,
%% an example Program Summary is included that only has to be
%% completed and which will give the correct layout in the
%% preprint and the journal.
%% The `elsarticle' style is used and more information on this style
%% can be found at 
%% http://www.elsevier.com/wps/find/authorsview.authors/elsarticle.
%%
%%
\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
\usepackage{graphics}
\usepackage{hyperref}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amsmath}
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

% \biboptions{}

\usepackage{color}
\usepackage{listings}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
%	backgroundcolor=\color{lbcolor},
        language=Mathematica,
	tabsize=2,
	rulecolor=,
        basicstyle=\scriptsize,
        upquote=true,
%        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
%        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
%        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\newcommand{\go}{\stackrel{\circ }{\mathfrak{g}}}
\newcommand{\ao}{\stackrel{\circ }{\mathfrak{a}}}
\newcommand{\co}[1]{\stackrel{\circ }{#1}}
\newcommand{\pia}{\pi_{\mathfrak{a}}}
\newcommand{\piab}{\pi_{\mathfrak{a}_{\bot}}}
\newcommand{\gf}{\mathfrak{g}}
\newcommand{\af}{\mathfrak{a}}
\newcommand{\bff}{\mathfrak{b}}
\newcommand{\afb}{\mathfrak{a}_{\bot}}
\newcommand{\hf}{\mathfrak{h}}
\newcommand{\hfg}{\hf_{\gf}}
\newcommand{\hfb}{\mathfrak{h}_{\bot}}
\newcommand{\pf}{\mathfrak{p}}

%% This list environment is used for the references in the
%% Program Summary
%%
\newcounter{bla}
\newenvironment{refnummer}{%
\list{[\arabic{bla}]}%
{\usecounter{bla}%
 \setlength{\itemindent}{0pt}%
 \setlength{\topsep}{0pt}%
 \setlength{\itemsep}{0pt}%
 \setlength{\labelsep}{2pt}%
 \setlength{\listparindent}{0pt}%
 \settowidth{\labelwidth}{[9]}%
 \setlength{\leftmargin}{\labelwidth}%
 \addtolength{\leftmargin}{\labelsep}%
 \setlength{\rightmargin}{0pt}}}
 {\endlist}

\journal{Computer Physics Communications}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{{\bf Affine.m} -- {\it Mathematica} package for computations in representation theory of finite-dimensional and affine Lie algebras}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author[a,b]{Anton Nazarov\corref{author}}
%\author[a,b]{Second Author}
%\author[b]{Third Author}

\cortext[author] {Corresponding author.\\\textit{E-mail address:} antonnaz@gmail.com}
\address[a]{Department of High Energy Physics, Faculty of physics, SPb State University\\ 198904, Sankt-Petersburg, Russia}
\address[b]{Chebyshev Laboratory, Faculty of Mathematics and Mechanics, SPb State University\\ 199178, Saint-Petersburg, Russia}

\begin{abstract}
%% Text of abstract
We present {\bf Affine.m} -- program for computations in representation theory of finite-dimensional and affine Lie algebras. Algorithms are based upon the properties of weights and Weyl symmetry. Central problems are weight multiplicity computation, branching of representation to representations of subalgebra and tensor product decomposition. These problems has numerous applications in physics.

Unique features of our programs are the treatment of affine Lie algebras and implementation in popular computer algebra system {\it Mathematica}.

% A submitted program is expected to be of benefit to other physicists or physical chemists, or be an exemplar of good programming practice, or illustrate new or novel programming techniques which are of importance to some branch of computational physics or physical chemistry.
%
% Acceptable program descriptions can take different forms. The following Long Write-Up structure is a suggested structure but it is not obligatory. Actual structure will depend on the length of the program, the extent to which the algorithms or software have already been described in literature, and the detail provided in the user manual.

%Your manuscript and figure sources should be submitted through the Elsevier Editorial System (EES) by using the online submission tool at \\
% http://www.ees.elsevier.com/cpc.

%In addition to the manuscript you must supply: the program source code; job control scripts, where applicable; a README file giving the names and a brief description of all the files that make up the package and clear instructions on the installation and execution of the program; sample input and output data for at least one comprehensive test run; and, where appropriate, a user manual. These should be sent, via email as a compressed archive file, to the CPC Program Librarian at cpc@qub.ac.uk.

\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
%keyword1; keyword2; keyword3; etc.

Mathematica; Lie algebra; affine Lie algebra; Kac-Moody algebra; root system; weights; irreducible modules, CFT, Integrable systems
\end{keyword}

\end{frontmatter}

%%
%% Start line numbering here if you want
%%
% \linenumbers

% Computer program descriptions should contain the following
% PROGRAM SUMMARY.

{\bf PROGRAM SUMMARY}%/NEW VERSION PROGRAM SUMMARY}
  %Delete as appropriate.

\begin{small}
\noindent
{\em Manuscript Title:}{\bf Affine.m} -- {\it Mathematica} package for computations in representation theory of finite-dimensional and affine Lie algebras                                       \\
{\em Authors:}Anton Nazarov                                                \\
{\em Program Title:}Affine.m                                          \\
{\em Journal Reference:}                                      \\
  %Leave blank, supplied by Elsevier.
{\em Catalogue identifier:}                                   \\
  %Leave blank, supplied by Elsevier.
{\em Licensing provisions:}none                                   \\
  %enter "none" if CPC non-profit use license is sufficient.
{\em Programming language:}Mathematica                                   \\
{\em Computer:}i386-i686, x86\textunderscore 64                                               \\
  %Computer(s) for which program has been designed.
{\em Operating system:} Linux, Windows, MacOS, Solaris                                       \\
  %Operating system(s) for which program has been designed.
{\em RAM:} 5-500 Mb                                              \\
  %RAM in bytes required to execute program with typical data.
%{\em Number of processors used:}                              \\
  %If more than one processor.
%{\em Supplementary material:}                                 \\
  % Fill in if necessary, otherwise leave out.
{\em Keywords:} Mathematica; Lie algebra; affine Lie algebra; Kac-Moody algebra; root system; weights; irreducible modules, CFT, Integrable systems\\
  % Please give some freely chosen keywords that we can use in a
  % cumulative keyword index.
{\em Classification:} 5 Computer Algebra, 4.2 Other algebras and groups                                         \\
  %Classify using CPC Program Library Subject Index, see (
  % http://cpc.cs.qub.ac.uk/subjectIndex/SUBJECT_index.html)
  %e.g. 4.4 Feynman diagrams, 5 Computer Algebra.
%{\em External routines/libraries:}                            \\
  % Fill in if necessary, otherwise leave out.
%{\em Subprograms used:}                                       \\
  %Fill in if necessary, otherwise leave out.
%{\em Catalogue identifier of previous version:}*              \\
  %Only required for a New Version summary, otherwise leave out.
%{\em Journal reference of previous version:}*                  \\
  %Only required for a New Version summary, otherwise leave out.
%{\em Does the new version supersede the previous version?:}*   \\
  %Only required for a New Version summary, otherwise leave out.
{\em Nature of problem:}\\
  %Describe the nature of the problem here.
Representation theory of finite-dimensional Lie algebras has many applications in different branches of physics, including elementary particle physics, molecular physics, nuclear physics. Representations of affine Lie algebras appear in string theories and two-dimensional conformal field theory which is used for the description of critical phenomena in two-dimensional systems. Also Lie symmetries play major role in study of quantum integrable systems. 
   \\
{\em Solution method:}\\
  %Describe the method solution here.
We work with weights and roots of finite-dimensional and affine Lie algebras and use Weyl symmetry extensively. Central problems which are the computations of weight multiplicities, branching and fusion coefficients are solved using one general recurrent algorithm based on generalization of Weyl character formula. We also offer alternative implementation based on Freudenthal multiplicity formula which can be faster in some cases. 
   \\
%{\em Reasons for the new version:}*\\
  %Only required for a New Version summary, otherwise leave out.
%   \\
%{\em Summary of revisions:}*\\
  %Only required for a New Version summary, otherwise leave out.
%   \\
{\em Restrictions:}\\
  %Describe any restrictions on the complexity of the problem here.
Computational complexity grows fast  with the rank of algebra, so computations for algebra of rank greater than 8 are non practical. 
   \\
{\em Unusual features:}\\
  %Describe any unusual features of the program/problem here.
We offer the possibility to use traditional mathematical notation for objects in representation theory of Lie algebras in computations if {\bf Affine.m} is used in {\it Mathematica} notebook interface. 
   \\
%{\em Additional comments:}\\
  %Provide any additional comments here.
%   \\
{\em Running time:}\\
  %Give an indication of the typical running time here.
From seconds to days depending on rank of algebra and complexity of representations.
   \\

% \begin{thebibliography}{0}
% \bibitem{1}Reference 1         % This list should only contain those items referenced in the                 
% \bibitem{2}Reference 2         % Program Summary section.   
% \bibitem{3}Reference 3         % Type references in text as [1], [2], etc.
%                                % This list is different from the bibliography at the end of 
%                                % the Long Write-Up.
% \end{thebibliography}
% * Items marked with an asterisk are only required for new versions
% of programs previously published in the CPC Program Library.\\
\end{small}


%% main text
\section{Introduction}
\label{intro}

Representation theory of Lie algebras is of central importance for different areas of physics and mathematics. Lie algebras are used to for the description of symmetries of quantum and classical systems. Computational method in representation theory have long history \cite{belinfante1989survey}, there exist numerous software packages for computations related to Lie algebras \cite{simplie}, \cite{vanleeuwen1994lsp}, \cite{stembridge1995mps,coxweyl}, \cite{fischbacher2002ilp}, \cite{Fuchs:1996dd}. 

Most popular programs \cite{simplie}, \cite{vanleeuwen1994lsp}, \cite{fischbacher2002ilp}, \cite{coxweyl} are created to study representation theory of simple finite-dimensional Lie algebras. The main computational problems are the following:
\begin{enumerate}
\item Construction of root system which is used for compact description of algebra commutation relations.
\item Weyl group traversal which is important due to Weyl symmetry of root system and characters of representations.
\item Calculation of weight multiplicities, branching and fusion coefficients, which are essential for the construction and study of representations. 
\end{enumerate}
There are well-known algorithms for these tasks \cite{moody1982fast}, \cite{stembridge2001computational}, \cite{belinfante1989survey}, \cite{casselman1994machine}. 
The third problem is most computation-intensive. There are two different recurrent algorithms which are based on Weyl character formula and Freudenthal multiplicity formula. In this paper we analyze them. 

Infinite-dimensional Lie algebras also have growing number of applications in physics for example in conformal field theory and study of quantum integrable systems. But infinite-dimensional algebras are much harder to study and quantity of available computer programs is much smaller.

Affine Lie algebras \cite{kac1990idl} constitute important and tractable class of infinite-dimensional Lie algebras. They are constructed as the central extensions of loop algebras of (semi-simple) finite-dimensional Lie algebras and appear naturally in the study of Wess-Zumino-Witten and coset models of conformal field theory \cite{Walton:1999xc}, \cite{difrancesco1997cft}, \cite{Goddard198588}, \cite{Dunbar:1992gh}. 

Construction of affine Lie algebras allows to extend computational algorithms created for finite-dimensional Lie algebras  \cite{Fuchs:1996dd}, \cite{gannon2001algorithms}, \cite{kass1990ala}. The book \cite{kass1990ala} with the tables of multiplicities and other computed characteristics of algebras and representations was published in 1990. But we are not aware of software packages for popular computer algebra systems which can be used to extend these results. 
We address this issue and present {\bf Affine.m} -- {\it Mathematica} package for computations in representation theory of affine and finite-dimensional Lie algebras. 

Our package can be used for study of root and weight systems, Weyl groups, subalgebras, computations of weight multiplicities, branching and fusion coefficients. We describe the features and limitations of the package in present paper and in the manual \cite{affinemanual}. In present paper we also provide representation-theoretical background of implemented algorithms and present some example of computations relevant to physics. 

The paper is started with overview of Lie algebras and their representation theory (Sec. \ref{sec:theor-backgr}). Then we describe datastructures of {\bf Affine.m} used to present different objects related to Lie algebras and their representations (Sec. \ref{sec:core-datastructures} and used in implemented algorithms (Sec. \ref{sec:comp-algor}). Next section consists of physically interesting examples (Sec. \ref{sec:examples}). The paper is concluded with the discussion of possible extensions and refinements (Sec. \ref{sec:conclusion}).

\section{Theoretical background}
\label{sec:theor-backgr}

\subsection{Lie algebras of finite and affine type}
\label{sec:lie-algebras-finite}

Lie algebra $\gf$ is a vector space with bilinear operation $[\cdot,\cdot]:\gf\otimes\gf\to \gf$, which is called commutator. If we choose the basis $X_{i}$ in $\gf$ we can specify commutation relations by the structure constants $C_{ijk}$:
\begin{equation}
  \label{eq:1}
  [X^{i},X^{j}]=\sum_{k} C^{ij}_{k} X^{k}
\end{equation}
Lie algebra is simple if it contains no non-trivial ideals. Semisimple Lie algebra is a direct sum of simple Lie algebras. 

Maximal commutative subalgebra (Cartan subalgebra) of $\gf$ is denoted by $\hfg$.
We denote the elements of basis of $\hfg$ by $H^{i}$.

Killing form gives non-degenerate bilinear form $(\cdot,\cdot)$ on $\hfg$ which can be extended to the dual space $\hfg^{*}$ of linear functionals on $\hfg$. Weights are the elements of $\hfg^{*}$ and are denoted by Greek letters $\mu,\nu, \omega, \lambda\dots$   

Special choice of basis gives compact description of commutation relations (\ref{eq:1}). This basis can be encoded by the root system  which is the set of vectors in  $\hfg^{*}$ satisfying certain properties (See e.g. \cite{humphreys1997introduction,humphreys1992reflection} for details). 

Loop algebra $L\gf=\gf\otimes \mathbb{C}[t,t^{-1}]$, corresponding to semisimple Lie algebra $\gf$ has commutation relations
\begin{equation}
  \label{eq:6}
  [X^{i}t^{n},X^{j}t^{m}]=t^{n_+m}\sum_{k}C^{ij}_{k}X^{k}
\end{equation}
Central extension leads to the appearance of additional term in commutation relations
\begin{equation}
  \label{eq:7}
   [X^{i}t^{n}+\alpha c,X^{j}t^{m}+\beta c]=t^{n+m}\sum_{k}C^{ij}_{k}X^{k}+(X^{i},X^{j})n\delta_{n+m,0}c
\end{equation}
This algebra $\hat\gf=\gf\otimes\mathbb{C}[t,t^{-1}]\oplus\mathbb{C}c$ is called {\it affine Lie algebra} \cite{kac1990idl}, \cite{wakimoto2001idl,wakimoto2001lectures}, \cite{kass1990ala}.

Sometimes we denote affine Lie algebra by $\gf$ then corresponding finite-dimensional Lie algebra is denoted by $\go$. 

\subsection{Weights and roots}
\label{sec:weights-roots}

Let $\gf$ be finite-dimensional or affine Lie algebra. 

Then $\gf$-module is a vector space $V$ together with a bilinear map $\gf \times V\to V$ such that
\begin{equation}
  \label{eq:2}
  [x,y]\cdot v = x\cdot(y\cdot v) - y\cdot(x\cdot v), \quad \mbox{for}\; x,y\in \gf, v\in V
\end{equation}
Representation of algebra $\gf$ on vector space $V$ is the homomorphism $\gf\to gl(V)$. 

For an arbitrary representation it is possible to diagonalize Cartan generators $H^{i}$ simultaneously by special choice of basis $\{v_{j}\}$ in $V$:
\begin{equation}
  \label{eq:3}
  H^{i}\cdot v_{j}=\nu_{j}^{i}v_{j}
\end{equation}
Eigenvalues of Cartan generators on element of basis $v_{j}$ are given by weight $\nu_{j}\in \hfg^{*}: \nu_{j}(H^{i})=\nu_{j}^{i}$. Vector $v\in V$ is called weight vector of weight $\lambda$ if $H v=\lambda_{j}(H)v,\; \forall H\in \hf$ , weight subspace consists of all weight vectors $V_{\lambda}=\{v\in V: H v=\lambda_{j}(H)v,\; \forall H\in \hf\}$. Weight multiplicity $m_{\lambda}=\mathrm{mult}(\lambda)=\mathrm{dim} V_{\lambda}$ is the dimension of weight subspace.

The structure of module is determined by the set of weights since the action of generators $E^{\alpha}$ on weight vectors is
\begin{equation}
  \label{eq:5}
  E^{\alpha}\cdot v_{\lambda} \propto v_{\lambda+\alpha}
\end{equation}
It can be encoded by the formal character of module
\begin{equation}
  \label{eq:10}
  \mathrm{ch}V=\sum_{\lambda}m_{\lambda} e^{\lambda}
\end{equation}
Character  $\mathrm{ch}V\in \mathcal{E}$ is the element of algebra $\mathcal{E}$ generated by formal exponents of weights.
It is possible to specialise character by taking its value on some element $\xi$ of $\hf$:

Roots are weights of adjoint representation of $\gf$ on itself. They encode the commutation relations of algebra in the following way. Denote by $\Delta$ the set of roots. For each $\alpha\in \Delta$ there exist root $-\alpha\in \Delta$ and generators $E^{\alpha}, E^{-\alpha}$ such that
\begin{align}
  \label{eq:4}
  &  [H^{i},E^{\alpha}]=\alpha^{i}E^{\alpha} \\
  &\left[E^{\alpha},E^{\beta}\right]=
  \begin{cases} 
    N_{\alpha,\beta} E^{\alpha+\beta}, & \mbox{if}\; \alpha+\beta\in \Delta\\
    \frac{2}{(\alpha,\alpha)} \sum_{i}\alpha^{i} H^{i},&  \mbox{if}\; \alpha=-\beta\\
    0,&\mbox{otherwise}
  \end{cases}
\end{align}
Highest weight of adjoint representation. 

%%  Given a root system Φ we can always choose (in many ways) a set of positive roots. This is a subset Φ + of Φ such that
%%  
%%      * For each root \alpha\in\Phi exactly one of the roots α, –α is contained in Φ + .
%%      * For any two distinct \alpha, \beta\in \Phi^+ such that α + β is a root, \alpha+\beta\in\Phi^+.
%%  
%%  If a set of positive roots Φ + is chosen, elements of –Φ + are called negative roots.
%%  
%%  An element of Φ + is called a simple root if it cannot be written as the sum of two elements of Φ + . The set Δ of simple roots is a basis of V with the property that every vector in Φ is a linear combination of elements of Δ with all coefficients non-negative, or all coefficients non-positive. For each choice of positive roots, the corresponding set of simple roots is the unique set of roots such that the positive roots are exactly those that can be expressed as a combination of them with non-negative coefficients, and such that these combinations are unique.
%%  
%%  Ordering. Highest root. Rho=sum of fundamental weights, not half-sum of positive roots.

In the root system $\Delta$ exist simple roots $\left\{\alpha_{i}\right\}$, such that $\alpha=\sum_{i}n_{i}\alpha_{i},\; \forall\alpha\in \Delta$. In case of finite-dimensional Lie algebra $\gf$ $i=1,\dots,r,\quad r=\mathrm{rank}(\gf)$. Although the full set of roots $\Delta$ is infinite for affine Lie algebra $\hat\gf$ the number of simple roots is finite and are denoted by $\alpha_{0},\dots \alpha_{r}$ where $r=\mathrm{rank}(\gf)$. The roots $\alpha_1,\dots, \alpha_r$ are equal to the roots of the underlying finite-dimensional Lie algebra $\go$. The root $\alpha_0=\delta-\theta$ is equal to the difference of {\it imaginary root} $\delta$ and $\theta=\sum_{i=1,\dots,r} a_i \alpha_i$ -- highest root of algebra $\go$, coefficients $a_i$ are called {\it marks}. {\it Comarcs} are equal to $a_i^v=\frac{(\alpha_i,\alpha_i)}{2} a_i$.

Roots system can be reconstructed from the set of simple roots with the use of Weyl group $W_{\gf}$ which is generated by reflections $\{s_{i}:\hfg^{*}\to\hfg^{*}\}$ corresponding to simple roots $\{\alpha_{i}\}$:
\begin{equation}
  \label{eq:8}
  s_{i}\cdot\lambda=\lambda-\frac{2(\alpha_{i},\lambda)}{(\alpha_{i},\alpha_{i})}\alpha_{i}
\end{equation}
Note that root multiplicity $\mathrm{mult}(\alpha)$ for affine Lie algebra can be greater than one. 

Weyl groups are finite for finite-dimensional Lie algebras and finitely-generated for affine Lie algebras. In the latter case of $\hat\gf$ Weyl group can be presented as semidirect product of Weyl group $W_{\gf}$ of $\gf$ and translations by the roots of $\hat \gf$.

Fundamental domain $\bar{C}$ for the action of Weyl group $W_{\gf}$ on $\hfg^{*}$ is determined by the requirement $\xi\in \bar{C}\Leftrightarrow (\xi,\alpha_{i})\geq 0$ for all simple roots $\alpha_{i}$. It is called {\it main Weyl chamber}.

Cartan matrix $A$ is defined by products of simple roots
\begin{equation}
  \label{eq:9}
  A_{ij}=\frac{2(\alpha_{i},\alpha_{j})}{(\alpha_{j},\alpha_{j})}
\end{equation}
and can be used for compact description of Lie algebra commutation relations in Chevalley basis \cite{humphreys1997introduction}, \cite{fulton1991representation}, \cite{bourbaki2002lie}.

Basis conjugate to the basis of simple roots with respect to the product $(\cdot,\cdot)$ is called basis of fundamental weights. We denote its elements by $\omega_i$.
\begin{equation}
  \label{eq:20}
  (\omega_i,\alpha_j)=\delta_{ij}
\end{equation}
For finite-dimensional Lie algebra $i=1,\dots, r$. For affine Lie algebra $\omega_0=\lambda$, $(\lambda,\delta)=1, \; (\lambda,\lambda)=(\delta,\delta)=0$. Other fundamental weights are equal to $\omega_i=a_i^v \lambda_0 +\co{\omega_i}$, where $\co{\omega_i}$ is the fundamental weight of finite-dimensional Lie algebra $\go$.

Weyl vector is denoted by $\rho=\sum_{i} \omega_{i}$, it is of importance for 
\subsection{Highest weight modules}
\label{sec:high-weight-modul}

We consider $\gf$-modules of the category $\mathcal{O}$, i.e. such $V$ that $V=\bigoplus_{\lambda\in \hfg^{*}} V_{\lambda}$, where each $V_{\lambda}$ is finite-dimensional and there exists finite set $\lambda_{1},\dots \lambda_{s}$ such that $V_{\lambda}\neq 0 \Rightarrow \lambda=\lambda_{i}-\sum_{k=1,\dots, r} n_{k}\alpha_{k}$, where $n_{k}\in \mathbb{Z}_{+}$ (See \cite{humphreys2008representations}, \cite{carter2005lie}).

Highest weight module $V^{\mu}$ contains one highest weight $\mu$, all other weights are obtained by the subtraction of linear combination of simple roots $\lambda=\mu-n_{1}\alpha_{1}-\dots-n_{r}\alpha_{r},\; n_{k}\in \mathbb{Z}_{+}$. 

The simplest type of highest weight modules is Verma module $M^{\mu}$ which can be defined as the space
\begin{equation}
  \label{eq:17}
  M^{\mu}=U(\gf)\underset{U(\bff_{+})}{\otimes} D_{\lambda}(\bff_{+}),
\end{equation}
where $\underset{U(\bff_{+})}{\otimes}$ means that the action of elements of $U(\bff_{+})$ ``falls through'' left part of tensor product onto the right part. Here $\bff_{+}$ is Borel sub-algebra, $D_{\lambda}(\bff_{+})$ is a special representation of $\bff_{+}$, such that $D(E^{\alpha})=0,\; D(h)=\lambda(h)$ for any positive root $\alpha$.
Elements of $\gf$ act from the left, so we should expand element of $\gf$ in some basis, and then commute all the elements of $\bff_{+}$ to the right, so that they can act on space $D_{\lambda}(\bff_{+})$.

Weight multiplicities of Verma module can be found from Weyl character formula
\begin{equation}
  \label{eq:11}
  \mathrm{ch} M^{\mu}=\frac{e^{\mu}}{\prod_{\alpha\in \Delta^{+}} \left( 1-e^{-\alpha}\right)^{\mathrm{mult}(\alpha)}}=\frac{e^{\mu}}{\sum_{w\in W} \epsilon(w) e^{w\rho-\rho}}
\end{equation}
Here we have used Weyl denominator identity
\begin{equation}
  \label{eq:12}
  \prod_{\alpha\in \Delta^{+}} \left( 1-e^{-\alpha}\right)^{\mathrm{mult}(\alpha)}=\sum_{w\in W} \epsilon(w) e^{w\rho-\rho},
\end{equation}
and $\epsilon \left( w\right) :=\det \left( w\right)$ is also equal to the parity of number of Weyl reflections generating $w$.

Construction of generalized Verma modules is analogous to (\ref{eq:17}), but representation of Borel subalgebra is substituted by the representation of some parabolic subalgebra $\pf_{I}\supset \bff_{+}$ generated by some subset of simple roots $I\subset \{\alpha_{1},\dots, \alpha_{r}\}$:
\begin{equation*}
M_{I}^{\mu}=U\left( \gf\right)\otimes _{U\left( \pf_{I}\right) }L_{\pf_{I}}^{\mu}.
\end{equation*}
Denote formal element $R_{I}:=\prod_{\alpha \in
\Delta ^{+}\setminus \Delta _{\pf_{I}}^{+}}\left( 1-e^{-\alpha
}\right) ^{\mathrm{mult}(\alpha )}$. Then the character of generalized Verma module can be written as
\begin{equation}
  \label{eq:18}
  \mathrm{ch}M_{I}^{\mu}=\frac{1}{R_{I}}\mathrm{ch}L_{\pf_{I}}^{\mu }.
\end{equation}

Verma module $M^{\mu}$ has unique maximal submodule and unique nontrivial simple quotient $L^{\mu}$ which is irreducible highest weight module. 
Weyl character formula for irreducible highest weight modules is
\begin{equation}
  \label{eq:13}
  \mathrm{ch} L^{\mu}=\frac{\sum_{w\in W} \epsilon(w) e^{w(\mu+\rho)-\rho}}{\sum_{w\in W}\epsilon(w) e^{w\rho-\rho}}=\sum_{w\in W} \epsilon(w)\; \mathrm{ch} M^{w(\mu+\rho)-\rho}
\end{equation}
So the character of irreducible highest weight module can be seen as the combination of characters of Verma modules, this is connected with Bernstein-Gelfand-Gelfand resolution (\cite{bernstein1976category,bernstein1971structure}, see also \cite{humphreys2008representations}). 

%% Define external border of representation 

We can use Weyl character formula to obtain recurrent relation on weight multiplicities which can be used for calculations \cite{il2010folded,kulish4sfa}:
\begin{equation}
\label{eq:14}
m_{\xi }=-\sum_{w\in W\setminus e}\epsilon (w)m_{\xi
-\left( w(\rho )-\rho \right) }+\sum_{w\in W}\epsilon
(w)\delta _{\left( w(\mu +\rho )-\rho \right) ,\xi }.  
\end{equation}

Another recurrent formula can be obtained from the study of Casimir elements action on irreducible highest weight modules \cite{humphreys1997introduction}:
\begin{equation}
  \label{eq:15}
  m_{\lambda}=\frac{2}{(\mu+\rho)^{2}-(\lambda+\rho)^{2}}\sum_{\alpha\in \Delta^{+}}\sum_{k\geq 1} (\lambda+k\alpha,\alpha)m_{\lambda+k\alpha}.
\end{equation}
It is called Freudenthal multiplicity formula. 

Now consider an algebra $\gf$ and subalgebra $\af\subset \gf$. Simple roots $\beta_{i}$ of the subalgebra $\af$ can be presented as the linear combinations of algebra roots $\alpha_{j}$: $\beta_{i}=\sum_{j=1,\dots,r_{\gf}}k_{j} \alpha_{j},\ j=1,\dots,r_{\af}$. 

We also need to introduce subalgebra $\afb$. 
Consider the root subspace $\hf_{\perp \af}^{\ast }$ orthogonal to
$\af$,
\begin{equation*}
\hf_{\perp \af}^{\ast }:=\left\{ \eta \in \hf^{\ast }|\forall
h\in \hf_{\af};\eta \left( h\right) =0\right\} ,
\end{equation*}
and the roots (correspondingly -- positive roots) of $\gf$ orthogonal
to $\af$,
\begin{eqnarray}
\Delta _{\afb} &:&=\left\{ \beta \in \Delta _{\gf}|\forall
h\in \hf_{\af};\beta \left( h\right) =0\right\} ,
\label{delta a ort} \\
\Delta _{\afb}^{+} &:&=\left\{ \beta ^{+}\in \Delta _{\gf%
}^{+}|\forall h\in \hf_{\af};\beta ^{+}\left( h\right) =0\right\} .
\notag
\end{eqnarray}
Let $W_{\afb}$ be the subgroup of $W$ generated by the
reflections $w_{\beta }$ with the roots $\beta \in \Delta _{\af_{\perp
}}^{+}$. The subsystem $\Delta _{\afb}$ determines the
subalgebra $\afb$ with the Cartan subalgebra $\hf_{\af%
_{\perp }}$. 

For $\af$ and $\afb$ consider the
corresponding Weyl vectors, $\rho _{\af}$ and $\rho _{\af_{\perp
}} $.

 Form the so called ''defects'' $\mathcal{D}_{\af}$ and $\mathcal{%
D}_{\afb}$ of the injection:
\begin{equation}
\mathcal{D}_{\af}:=\rho _{\af}-\pi _{\af}\rho , \qquad
\mathcal{D}_{\afb}:=\rho _{\afb}-\pi _{\af%
_{\perp }}\rho .  \label{defect-ort}
\end{equation}

For $\mu \in P^{+}$ consider the linked weights $\left\{
\left( w(\mu +\rho )-\rho \right) |w\in W\right\} $. Consider the projections to
$h_{\afb}^{\ast }$ additionally shifted by the defect $-%
\mathcal{D}_{\afb}$:
\begin{equation*}
\mu _{\afb}\left( w\right) :=\pi _{\afb}\left[
w(\mu +\rho )-\rho \right] -\mathcal{D}_{\afb},\quad w\in W.
\end{equation*}
Among the weights $\left\{ \mu _{\af_{\perp
}}\left( w\right) |w\in W\right\} $ one can always choose those located in
the fundamental chamber $\overline{C_{\afb}}$. Let $U$ be the
set of representatives $u$ for the classes $W/W_{\afb}$ such
that

\begin{equation}
U:=\left\{ u\in W|\quad \mu _{\afb}\left( u\right) \in
\overline{C_{\afb}}\right\} \quad .  \label{U-def}
\end{equation}
Thus we can form the subsets:
\begin{equation}
\mu _{\widetilde{\mathfrak{a}}}\left( u\right) :=\pi _{\widetilde{%
\mathfrak{a}}}\left[ u(\mu +\rho )-\rho \right] +\mathcal{D}_{\af%
_{\perp }},\quad u\in U,  \label{mu-a}
\end{equation}
and
\begin{equation}
\mu _{\afb}\left( u\right) :=\pi _{\afb}\left[
u(\mu +\rho )-\rho \right] -\mathcal{D}_{\afb},\quad u\in U.
\label{mu-a-tilda}
\end{equation}

Notice that the subalgebra $\mathfrak{a}_{\bot}$ is regular by definition
since it is built on a subset of roots of the algebra $\mathfrak{g}$.

Each $\gf$-module is also $\af$-module, although $L^{\mu}_{\gf}$ is not irreducible as $\af$-module. It can be decomposed into the sum of irreducible $\af$-modules:
\begin{equation}
  \label{eq:16}
  L^{\mu}_{\gf}=\bigoplus_{\nu}b^{\mu}_{\nu}L^{\nu}_{\af}
\end{equation}
Coefficients in this decomposition are called branching coefficients. 
Using Weyl character formula we can write recurrent relation \cite{2010arXiv1007.0318L} for branching coefficients $k_{\xi
}^{\left( \mu \right) }$ corresponding to the injection $\af\hookrightarrow \gf$:
\begin{equation}
\begin{array}{c}
k_{\xi }^{\left( \mu \right) }=-\frac{1}{s\left( \gamma _{0}\right) }\left(
\sum_{u\in U}\epsilon (u)\;\dim \left( L_{\afb}^{\mu _{\af%
_{\perp }}\left( u\right) }\right) \delta _{\xi -\gamma _{0},\pi _{%
\widetilde{\af}}(u(\mu +\rho )-\rho )}+\right.  \\
\left. +\sum_{\gamma \in \Gamma _{\widetilde{\af}\rightarrow \gf%
}}s\left( \gamma +\gamma _{0}\right) k_{\xi +\gamma }^{\left( \mu \right)
}\right) .
\end{array}
\label{recurrent-rel}
\end{equation}
The recursion is goverened by the set $\Gamma _{\widetilde{\af}\rightarrow \gf}$ called the injection fan. The latter is defined by the
carrier set $\left\{ \xi \right\} _{\af\rightarrow \gf}$ for the
coefficient function $s(\xi )$
\begin{equation*}
\left\{ \xi \right\} _{\widetilde{\af}\rightarrow \gf}:=\left\{
\xi \in P_{\widetilde{\af}}|s(\xi )\neq 0\right\}
\end{equation*}
appearing in the expansion
\begin{equation}
\prod_{\alpha \in \Delta ^{+}\setminus \Delta _{\bot }^{+}}\left( 1-e^{-\pi
_{\widetilde{\af}}\alpha }\right) ^{\mathrm{mult}(\alpha )-\mathrm{mult}%
_{\af}(\pi _{\widetilde{\af}}\alpha )}=-\sum_{\gamma \in P_{%
\widetilde{\af}}}s(\gamma )e^{-\gamma };\quad
\end{equation}
The weights in $\left\{ \xi \right\} _{\widetilde{\af}\rightarrow \frak{%
g}}$ are to be shifted by $\gamma _{0}$ -- the lowest vector in $\left\{ \xi
\right\} $ -- and the zero element is to be eliminated:
\begin{equation}
\Gamma _{\widetilde{\af}\rightarrow \gf}=\left\{ \xi -\gamma
_{0}|\xi \in \left\{ \xi \right\} \right\} \setminus \left\{ 0\right\} .
\end{equation}
The formula (\ref{eq:14}) is a particular case of recurrent relation for branching coefficients (\ref{recurrent-rel}) in the case of Cartan subalgebra $\af=\hfg$.

If root system of $\afb$ is generated by some subset of algebra $\gf$ simple roots $\alpha_{1},\dots,\alpha_{r}$ then recurrent relation (\ref{recurrent-rel}) is connected with generalized Bernstein-Bernstein-Gelfand resolution for parabolic Verma modules \cite{2011arXiv1102.1702L}.

Another particular case of this formula is connected with tensor product decomposition. Consider tensor product of two irreducible $\gf$-modules $L^{\mu}\otimes L^{\nu}$. It is also $\gf$-module but not irreducible in general. So
\begin{equation}
  \label{eq:19}
  L^{\mu}\otimes L^{\nu}=\bigoplus_{\gamma} f^{\mu\nu}_{\gamma}L^{\gamma}
\end{equation}
The coefficients $f^{\mu\nu}_{\gamma}$ are called fusion coefficients. The problem of computation of fusion coefficients is equivalent to branching problem for diagonal subalgebra $\gf\subset \gf\otimes \gf$ (see \cite{LyakhovskyPostnova2011}).

In the case of affine Lie algebras $\gf, \af$  multiplicities $m_{\nu}$ and branching coefficients $b_{\nu}$ can be regarded as the coefficients in power series decomposition of string and branching functions correspondingly:
\begin{align}
  \label{eq:21}
  &\sigma_{\nu}(q)=\sum_{n=0}^{\infty} m_{\nu-n\delta} q^n, \quad \nu=\sum_j c_j \omega_j,\quad c_j\geq 0\\
  & b_{\nu}(q)=\sum_{n=0}^{\infty} b_{\nu-n\delta} q^n,\quad  \nu=\sum_j c_j \omega_j, \quad c_j\geq 0
\end{align}

String and branching functions have  modular and analytic properties which are important for conformal field theory, especially in  coset models and the study of CFT on higher genus surfaces \cite{kac1988modular}, \cite{difrancesco1997cft}, \cite{Walton:1999xc}, \cite{walton1989conformal}. 

\section{Core datastructures}
\label{sec:core-datastructures}
Having introduced required mathematical objects, problems and relations we now describe the related datastructures introduced in {\bf Affine.m}. 
Although {\it Mathematica} is untyped language it is possible to create structured objects and do type checks with patterns \cite{shifrinmathematica}, \cite{maeder2000computer}. 
\subsection{Weights}
\label{sec:weights}

Weights are represented  by two data-structures: \lstinline{finiteWeight} for finite-dimensional Lie algebras and \lstinline{affineWeight}  for affine. 

Internally finite weight is a \lstinline{List} with the \lstinline{Head} \lstinline{finiteWeight}, its components are the coordinates of weight in orthogonal basis of \cite{bourbaki2002lie}. 

Affine weight is the extension of finite weight by the addition of level and grade. There are number of functions defined for finite and affine weights. Complete list can be found in user manual \cite{affinemanual}. The most important are the definitions of addition, multiplication by number and scalar product (bilinear form) for weights. These definitions allow to use traditional notation when working with {\bf Affine.m}:
\begin{lstlisting}
  w=makeFiniteWeight[{1,0,3}];
  v=makeFiniteWeight[{3,2,1}];
  2*w+v==makeFiniteWeight[{5,2,7}]
  w.v==6
\end{lstlisting}

The use of orthogonal basis in the internal structure of weights allows us to work with weights without complete specification of root system which is useful for study of branching, since roots of the subalgebra can be specified by hand.

\subsection{Root systems}
\label{sec:root-systems}

To specify an algebra of finite or affine type it is enough to supply its root system. Root systems are represented by two datatypes \lstinline{finiteRootSystem} and \lstinline{affineRootSystem}. The latter is an extension of the former. 
We offer several different constructors for these datastructures. 
It is possible to specify the set of simple roots explicitly, for example to study the subalgebra $B_2\subset B_4$ we can use the definition
\begin{lstlisting}
  b2b4=makeFiniteRootSystem[ { {1,-1,0,0}, {0,1,0,0} } ]
\end{lstlisting}
There are constructors for root systems of simple finite-dimensional Lie algebras:
\begin{lstlisting}
  b2=makeSimpleRootSystem[B,2]
\end{lstlisting}
We use typographic features of {\it Mathematica} frontend to offer traditional mathematical notation for simple Lie algebras:


\begin{lstlisting}[mathescape=true]
  $B_2$ == finiteRootSystem[2, 2, {finiteWeight[2, {1, -1}], finiteWeight[2,{0, 1}]}]}
\end{lstlisting}

Non-twisted affine root systems can be created as affine extensions of finte root systems, e.g.
\begin{lstlisting}
  b2affine = makeAffineExtension[b2]
\end{lstlisting}
In notebook interface this can be written simply as $\hat{B}_2$. 

Semisimple Lie algebras can be created as sums of simple:
\begin{lstlisting}[mathescape=true]
  $A_1$+$A_1$ == finiteRootSystem[2, 2, {finiteWeight[2, {1, 0}], finiteWeight[2, {0, 1}]}]
\end{lstlisting}

Predicate \lstinline{rootSystemQ} checks if the object is root systems of finite or affine type. 

List of simple roots is the property of root system so it is accessed as \lstinline{rs[simpleRoots]}. 

We have implemented several functions to get major properties of root systems. Weyl vector is given by the function \lstinline{rho[rs_?rootSystemQ]}:
\begin{lstlisting}[label=list:1]
  rho[b2]
  finiteWeight[2, {3/2, 1/2}]
\end{lstlisting}
Positive roots can be constructed with \lstinline{positiveRoots[rs_?rootSystemQ]}. For affine Lie algebra this and related functions return the list up to fixed grade. This grade limit is set through the value of \lstinline{rs[gradeLimit]} which is equal to 10 by default. List of roots (up to \lstinline{gradeLimit}) is returned by \lstinline{roots[rs]}. Cartan matrix and fundamental weights are calculated by the functions \lstinline{cartanMatrix} and \lstinline{fundamentalWeights} correspondingly. 

It is possible to specify a weight of Lie algebra by its Dynkin label
\begin{lstlisting}
  weight[b2][1,2,3] == makeFiniteWeight[{2, 1}]
\end{lstlisting}
The function \lstinline{dynkinLabels[rs_?rootSystemQ][wg_?weightQ]} returns Dynkin labels of weight \lstinline{wg} in the root system \lstinline{rs}.

Elements of Weyl group are specified by the set of indices of reflections, so element of Weyl group of algebra $B_{2}$ which is equal to $w=s_{1}s_{2}s_{1}$ is constructed with \lstinline{weylGroupElement[b2][1,2,1]}. Then it can be applied to the weights:
\begin{lstlisting}
  w = weylGroupElement[b2][1,2,1];
  w @ makeFiniteWeight[{1,0}] == makeFiniteWeight[{-1,0}]
\end{lstlisting}

Computation of ShortLex form \cite{casselman1994machine,casselman1995automata} for Weyl group elements can be conveniently implemented through the use of pattern-matching features of {\it Mathematica}. In \cite{KallenShortlex} rewrite rules for simple finite dimensional and affine Lie algebras are presented as {\it Mathematica} patterns. Our presentation of Weyl group elements is compatible with the code of \cite{KallenShortlex}
\begin{lstlisting}[mathescape=true]
  In[1]  = $<<$A3reduce;
           reduce[s[1,2,1,2,1,3,2,1,1]]
  Out[1] = s[2, 3, 2]

  In[2]  = (weylGroupElement[$A_{3}$] @@ reduce[s[1,2,1,2,1,3,2,1,1]]) @ weight[$A_{3}$][-1,-2,-1]
  Out[2] = finiteWeight[4, {-2, 2, 1, -1}]

  In[3]  = dynkinLabels[$A_{3}$][Out[2]]
  Out[3] = {-4, 1, 2}
\end{lstlisting}

\subsection{Formal elements}
\label{sec:formal-elements}

We represent formal characters of representations by special structure \lstinline{formalElements}. This structure is a hash-table implemented with \lstinline{DownValues}. The keys are weights at the exponents and the values are corresponding multiplicities. \lstinline[mathescape=true]!makeFormalElement[{$\gamma_{1},\dots,\gamma_{n}$},{$m_{1},\dots,m_{n}$}]! creates data-structure which represents the element $\sum_{i=1}^{n} m_{i} e^{\gamma_{i}}$ of formal algebra $\mathcal{E}$. The operations of formal algebra $\mathcal{E}$ are implemented for \lstinline{formalElement} data-type: formal elements can be added, multiplied by number or exponent of weight. There is also multiplication of formal elements but no division.
\begin{lstlisting}[mathescape=true]
  In[1]  = makeFormalElement[{makeFiniteWeight[{1,1}],makeFiniteWeight[{0,0}]},{1,2}] *
             (2 * Exp[makeFiniteWeight[{1,0}]] *
             makeFormalElement[{makeFiniteWeight[{1,1}],makeFiniteWeight[{0,0}]},{1,2}]);
  In[2]  = In[1][weights]
  Out[2] = {finiteWeight[2, {1, 0}], finiteWeight[2, {2, 1}], finiteWeight[2, {3, 2}]}

  In[3]  = In[1][multiplicities]
  Out[3]= {8, 8, 2}
\end{lstlisting}

\section{Computational algorithms}
\label{sec:comp-algor}

As we have already stated in section \ref{sec:high-weight-modul} there exist two recurrent relations which can be used to calculate weight multiplicities in irreducible modules. Both algorithms proceed in the following way to calculate weight multiplicities:
\begin{enumerate}
\item Create the list of weights in main Weyl chamber by subtraction of all possible combinations of simple roots from the highest weight (e.g. for finite-dimensional algebra subtract $\alpha_{1}$ from $\mu$ while inside $\bar C$, then subtract $\alpha_{2}$ from all the weights already obtained etc).
\item Sort the list of weights by their product with Weyl vector.
\item Use a recurrent formula. If the weight required for recurrent computation is outside the main chamber use Weyl symmetry. 
\end{enumerate}
The difference in performance of algorithms is in the number of previous values required to get the multiplicity of weight under consideration. For recurrent relation \eqref{eq:14} it is constant and equal to the number of elements in Weyl group (if we are far from the boundary of representation diagram). When Freudenthal formula \eqref{eq:15} is used number of previous values grows with the distance from the external border of representation. So Freudenthal formula is faster if the weight is close to the border or the rank of the algebra and the size of Weyl group is large \cite{moody1982fast}. 
But Freudenthal formula is of no use if we are interested in Verma modules. 

In the calculation of branching coefficients use of Freudenthal formula requires full construction of formal characters of algebra representation and all the representations of subalgebra. It is impractical when the rank of algebra and subalgebra are big, for example for maximal subalgebra.

Branching algorithm \cite{2010arXiv1007.0318L}
\subsection{Performance testing}
\label{sec:performance-testing}

We have made some experiments with our implementations of Freudenthal formula and formula \eqref{eq:15} and have got the following graphs \ref{freudenthal-racah-times}.

\begin{figure}[h]
  \label{freudenthal-racah-times}
  \noindent\centering{
 %   \includegraphics[width=80mm]{figure1.eps}
  }
  \caption{Freudenthal run time with the number of weights in $\bar C$.}

  \noindent\centering{
 %   \includegraphics[width=80mm]{figure1.eps}
  }
  \caption{Racah run time with the number of weights in $\bar C$.}

  \noindent\centering{
 %   \includegraphics[width=80mm]{figure1.eps}
  }
  \caption{Freudenthal run time with rank of the algebra}

  \noindent\centering{
 %   \includegraphics[width=80mm]{figure1.eps}
  }
  \caption{Racah run time with rank of the algebra}
\end{figure}

Measurements for branching computations for $\hat B_{3}\subset \hat B_{4}$ are shown at the Fig. \ref{fig:branching}.
\begin{figure}[h]
  \label{fig:branching}
  \noindent\centering{
 %   \includegraphics[width=80mm]{figure1.eps}
  }
  \caption{Branching}
\end{figure}

\section{Examples}
\label{sec:examples}
In this section we present some examples of computations available with {\bf Affine.m} with the code required to produce these results. 

\section{Conclusion}
\label{sec:conclusion}
We present the package {\bf Affine.m} for computations in representation theory of finite-dimensional and affine Lie algebras. The package is available from {\it github} and is also submitted to the library. 

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% References
%%
%% Following citation commands can be used in the body text:
%% Usage of \cite is as follows:
%%   \cite{key}         ==>>  [#]
%%   \cite[chap. 2]{key} ==>> [#, chap. 2]
%%

%% References with bibTeX database:

\bibliographystyle{elsarticle-num}
\bibliography{bibliography}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use elsarticle-num.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have the following form:
%%   \bibitem{key}...
%%

% \bibitem{}

% \end{thebibliography}


\end{document}

%%
%% End of file 